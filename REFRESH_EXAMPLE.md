# 刷新机制示例说明

## 三种场景对比

### ❌ 会去重：快速切换（500ms 内）

```
时间轴：
00:00.000 - 用户点击"目标"页面 → GET /api/goals/long-term/
00:00.100 - 用户快速点击"首页"
00:00.150 - 用户再次点击"目标"页面 → GET /api/goals/long-term/ ❌ 被去重（150ms < 500ms）
00:00.600 - 用户第三次点击"目标"页面 → GET /api/goals/long-term/ ✅ 允许（600ms > 500ms）
```

**结果：** 减少了一次重复请求，但数据仍会在 600ms 后刷新

---

### ✅ 会刷新：正常使用（超过 500ms）

```
时间轴：
00:00.000 - 用户在"首页"
00:05.000 - 用户切换到"目标"页面 → GET /api/goals/long-term/ ✅ 允许（5秒 > 500ms）
00:30.000 - 用户回到"首页"
00:35.000 - 用户再次切换到"目标"页面 → GET /api/goals/long-term/ ✅ 允许（5秒 > 500ms）
```

**结果：** 每次切换都能获取最新数据，完全正常刷新

---

### ✅ 会刷新：强制刷新

```typescript
// 手动刷新按钮
const handleRefresh = () => {
  // forceRefresh = true，跳过去重检查
  fetchData(true);
};

// 即使 100ms 前刚请求过，也会立即发送新请求
```

**结果：** 立即获取最新数据，不受去重影响

---

## 实际测试场景

### 场景 1: 用户在页面停留 1 分钟

```
操作：
1. 进入"目标"页面（00:00）
2. 浏览内容 1 分钟
3. 切换到"首页"（01:00）
4. 再次切换回"目标"页面（01:05）

结果：
✅ 第 4 步的请求会被允许（间隔 65 秒，远超过 500ms）
✅ 数据正常刷新，显示最新内容
```

### 场景 2: 用户快速连续点击导航

```
操作：
1. 点击"目标"（00:00.000）
2. 立即点击"首页"（00:00.100）
3. 立即点击"目标"（00:00.200）
4. 立即点击"首页"（00:00.300）

结果：
✅ 第 1 步和第 3 步的请求会被去重（间隔 200ms < 500ms）
✅ 减少服务器压力，但用户体验不受影响
✅ 如果用户停止快速点击，下次切换时数据会正常刷新
```

### 场景 3: 数据更新后查看

```
操作：
1. 在"目标"页面看到旧数据
2. 切换到"首页"（00:00）
3. 在后台数据更新
4. 30 秒后切换回"目标"页面（00:30）

结果：
✅ 第 4 步的请求会被允许（间隔 30 秒 > 500ms）
✅ 获取最新数据，显示更新后的内容
```

---

## 关键点总结

### ✅ 不会阻止刷新的情况

1. **正常切换页面**（间隔 > 500ms）
2. **在页面停留一段时间后切换**（间隔 > 500ms）
3. **使用强制刷新参数**（`forceRefresh=true`）
4. **缓存过期后**（5 分钟缓存机制配合使用）
5. **用户手动刷新**（可以通过 forceRefresh 实现）

### ❌ 会去重的情况

1. **500ms 内快速切换**（这是我们的目标场景）
2. **组件快速重新挂载**（React StrictMode 或快速导航）

---

## 时间窗口说明

```
500ms = 0.5 秒

这是一个非常短的时间窗口，只针对：
- 快速连续点击导航栏
- 组件快速重新挂载

正常使用中，用户的操作间隔通常超过 500ms：
- 浏览内容：几秒到几分钟
- 切换页面：至少 1-2 秒
- 查看详情后再返回：通常超过 5 秒

因此，正常使用中几乎不会被去重影响。
```

---

## 如果仍然担心

如果您觉得 500ms 太短或太长，可以调整：

```typescript
// 在 requestDeduplicator.ts 中修改
const DEDUP_WINDOW = 300;  // 更短（300ms）
// 或
const DEDUP_WINDOW = 1000; // 更长（1秒）

// 但建议：
// - 300ms：可能无法有效去重快速切换
// - 1000ms：可能会影响正常刷新
// - 500ms：最佳平衡点 ✅
```

或者，可以完全禁用去重（如果不需要）：

```typescript
// 不调用 deduplicateRequest，直接发送请求
// 但这会导致您看到的重复请求问题
```

---

## 总结

**请求去重机制不会阻止正常刷新，因为：**

1. ✅ 时间窗口很小（500ms），只针对快速切换
2. ✅ 超过时间窗口的请求会被允许
3. ✅ 支持强制刷新参数
4. ✅ 配合缓存机制，确保数据及时更新

**只有在以下情况下才会去重：**
- 500ms 内的相同请求
- 这是为了避免快速切换时的重复请求

**正常使用中，数据会正常刷新！** ✅
