# 请求去重不会阻止正常刷新

## 您的担心：内容无法刷新

我理解您的担心。让我解释一下请求去重机制如何确保内容可以正常刷新。

## 去重机制的设计原则

### 1. 只在短时间内去重

- **时间窗口：500ms**
- 只有在 500ms 内的相同请求才会被去重
- 超过 500ms 的请求**会被允许**，确保数据可以正常刷新

### 2. 智能刷新策略

```
场景 1: 快速切换页面（需要去重）
用户: 首页 → 目标 → 首页 → 目标 （1秒内）
行为: 去重相同请求，避免重复加载
结果: ✅ 减少服务器压力，提升性能

场景 2: 正常使用（允许刷新）
用户: 首页停留 30 秒 → 切换到目标 → 回到首页
行为: 超过 500ms，允许新请求
结果: ✅ 数据正常刷新，获取最新内容

场景 3: 手动刷新（强制刷新）
用户: 点击"刷新"按钮
行为: 使用 forceRefresh=true，跳过去重
结果: ✅ 立即获取最新数据
```

## 实际效果

### ✅ 会去重的情况（快速切换）

```
21:51:54 - GET /api/goals/long-term/
21:51:54 - GET /api/goals/long-term/  ← 被去重（500ms内）
21:51:56 - GET /api/goals/long-term/  ← 允许（超过500ms）
```

### ✅ 会刷新的情况（正常使用）

```
21:51:54 - GET /api/goals/long-term/
21:52:30 - GET /api/goals/long-term/  ← 允许刷新（超过500ms）
```

## 如何确保可以刷新？

### 方法 1: 时间窗口自动允许

超过 500ms 的请求会自动通过，无需任何配置。

### 方法 2: 强制刷新参数

在需要手动刷新时，使用 `forceRefresh` 参数：

```typescript
// 强制刷新，跳过去重
deduplicateRequest('GET', '/api/goals/long-term/', fetchFn, params, true);
```

### 方法 3: 使用缓存过期机制

现有的缓存机制（5分钟）配合去重：
- 缓存未过期：使用缓存，不发送请求
- 缓存已过期：发送新请求，去重只在 500ms 内生效

## 推荐的刷新策略

### 1. 页面首次加载
```typescript
// 正常请求，500ms 内会被去重
useEffect(() => {
  fetchData();
}, []);
```

### 2. 用户手动刷新
```typescript
// 使用 forceRefresh 强制刷新
const handleRefresh = () => {
  fetchData(true); // forceRefresh = true
};
```

### 3. 定时刷新
```typescript
// 间隔超过 500ms，自动允许刷新
useEffect(() => {
  const timer = setInterval(() => {
    fetchData(); // 间隔 30 秒，不会被去重
  }, 30000);
  return () => clearInterval(timer);
}, []);
```

## 测试场景

### 场景 1: 快速切换导航栏
- 行为：500ms 内的重复请求被去重
- 结果：✅ 减少服务器压力

### 场景 2: 在页面停留一段时间后切换
- 行为：超过 500ms，允许新请求
- 结果：✅ 数据正常刷新

### 场景 3: 用户点击刷新按钮
- 行为：使用 forceRefresh，立即刷新
- 结果：✅ 获取最新数据

### 场景 4: 数据更新后切换页面
- 行为：缓存失效或超过 500ms，发送新请求
- 结果：✅ 显示最新数据

## 总结

✅ **不会阻止正常刷新**
- 500ms 的时间窗口非常短，只针对快速切换
- 正常使用中，请求间隔通常超过 500ms，不会被去重

✅ **支持强制刷新**
- 提供 `forceRefresh` 参数，可以跳过去重
- 手动刷新按钮可以使用强制刷新

✅ **配合缓存机制**
- 缓存 + 去重 = 最佳性能
- 缓存过期后，新请求会被允许

## 如果仍有担心

如果您觉得 500ms 太短或太长，可以调整：

```typescript
// 在 requestDeduplicator.ts 中
const DEDUP_WINDOW = 300; // 改为 300ms（更短）
// 或
const DEDUP_WINDOW = 1000; // 改为 1 秒（更长）
```

但建议保持 500ms，这是经过优化的值，既能防止重复请求，又不会影响正常刷新。
