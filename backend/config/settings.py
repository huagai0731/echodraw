"""
Django settings for config project.

Generated by 'django-admin startproject' using Django 5.2.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""

import os
from pathlib import Path

from dotenv import load_dotenv  # type: ignore

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

load_dotenv(BASE_DIR / ".env")
load_dotenv(BASE_DIR / ".env.local")
load_dotenv(BASE_DIR / ".env.development", override=True)


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
# 生产环境必须设置 DJANGO_SECRET_KEY 环境变量，不允许使用默认值
SECRET_KEY = os.getenv("DJANGO_SECRET_KEY")
if not SECRET_KEY:
    import sys
    print(
        "错误: 生产环境必须设置 DJANGO_SECRET_KEY 环境变量！",
        file=sys.stderr
    )
    print(
        "提示: 可以使用以下命令生成密钥: python -c \"import secrets; print(secrets.token_urlsafe(50))\"",
        file=sys.stderr
    )
    # 仅在开发环境允许使用默认值（不推荐）
    _is_dev = os.getenv("DJANGO_ENVIRONMENT", "").lower() == "development"
    if _is_dev:
        SECRET_KEY = "django-insecure-cek3ua7xe03xkv)eoj&(f30fc8=_^#&l9slh-)vl85$q(qr_o1"
        print("警告: 使用不安全的默认SECRET_KEY，仅用于开发环境", file=sys.stderr)
    else:
        raise ValueError("DJANGO_SECRET_KEY 环境变量未设置！生产环境必须设置此变量。")

# SECURITY WARNING: don't run with debug turned on in production!
# 生产环境默认为False，必须通过环境变量明确设置为True才能启用DEBUG
DEBUG = os.getenv("DJANGO_DEBUG", "False").lower() == "true"

_allowed_hosts = os.getenv("DJANGO_ALLOWED_HOSTS", "")
ALLOWED_HOSTS = [host.strip() for host in _allowed_hosts.split(",") if host.strip()]

# 开发环境自动添加本地地址
if DEBUG:
    # 开发环境允许所有主机，或添加常见的本地地址
    if not ALLOWED_HOSTS:
        ALLOWED_HOSTS = ["*"]
    else:
        # 如果已设置，确保包含本地地址和局域网地址
        local_hosts = ["localhost", "127.0.0.1", "0.0.0.0", "192.168.3.3"]
        for host in local_hosts:
            if host not in ALLOWED_HOSTS:
                ALLOWED_HOSTS.append(host)
else:
    # 生产环境必须设置ALLOWED_HOSTS
    if not ALLOWED_HOSTS:
        import sys
        print(
            "错误: 生产环境必须设置 DJANGO_ALLOWED_HOSTS 环境变量！",
            file=sys.stderr
        )
        print(
            "示例: DJANGO_ALLOWED_HOSTS=echodraw.com,www.echodraw.com",
            file=sys.stderr
        )
        # 生产环境不允许空ALLOWED_HOSTS，但为了不阻止启动，先设置为空列表
        # 实际部署时应该设置正确的值
        ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "storages",
    "corsheaders",
    "rest_framework",
    "core",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
]

ROOT_URLCONF = "config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [BASE_DIR / "templates"],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "config.wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# 数据库配置：支持SQLite（开发）和MySQL/PostgreSQL（生产）
# 如果设置了数据库环境变量，使用MySQL/PostgreSQL；否则使用SQLite（仅开发环境）
_db_engine = os.getenv("DJANGO_DB_ENGINE") or os.getenv("DB_ENGINE", "")
if _db_engine:
    _db_engine = _db_engine.lower()
_db_name = os.getenv("DB_NAME", "")
_db_user = os.getenv("DB_USER", "")
_db_password = os.getenv("DB_PASSWORD", "")
_db_host = os.getenv("DB_HOST", "localhost")
_db_port = os.getenv("DB_PORT", "")

if _db_engine and _db_name and _db_user:
    # 使用MySQL或PostgreSQL
    if _db_engine in ["mysql", "django.db.backends.mysql"]:
        # 尝试使用 PyMySQL 作为 MySQL 驱动（支持更多连接方式）
        try:
            import pymysql
            pymysql.install_as_MySQLdb()
        except ImportError:
            pass
        
        DATABASES = {
            "default": {
                "ENGINE": "django.db.backends.mysql",
                "NAME": _db_name,
                "USER": _db_user,
                "PASSWORD": _db_password,
                "HOST": _db_host,
                "PORT": _db_port or "3306",
                "OPTIONS": {
                    "charset": "utf8mb4",
                    "init_command": "SET sql_mode='STRICT_TRANS_TABLES'",
                    "sql_mode": "STRICT_TRANS_TABLES",
                },
                "CONN_MAX_AGE": 600,  # 连接复用10分钟，减少连接创建开销，提高并发性能
            }
        }
    elif _db_engine in ["postgresql", "postgres", "django.db.backends.postgresql"]:
        DATABASES = {
            "default": {
                "ENGINE": "django.db.backends.postgresql",
                "NAME": _db_name,
                "USER": _db_user,
                "PASSWORD": _db_password,
                "HOST": _db_host,
                "PORT": _db_port or "5432",
                "CONN_MAX_AGE": 600,  # 连接复用10分钟，减少连接创建开销，提高并发性能
            }
        }
    else:
        raise ValueError(f"不支持的数据库引擎: {_db_engine}。支持: mysql, postgresql")
else:
    # 使用SQLite（仅开发环境）
    if not DEBUG:
        import sys
        print(
            "警告: 生产环境应使用MySQL或PostgreSQL，当前使用SQLite",
            file=sys.stderr
        )
        print(
            "提示: 设置环境变量 DJANGO_DB_ENGINE、DB_NAME、DB_USER、DB_PASSWORD",
            file=sys.stderr
        )
    DATABASES = {
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
            "NAME": BASE_DIR / "db.sqlite3",
        }
    }


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.2/topics/i18n/

LANGUAGE_CODE = "en-us"

TIME_ZONE = "UTC"

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = "static/"
STATIC_ROOT = BASE_DIR / "staticfiles"
STATICFILES_DIRS = [BASE_DIR / "static"]

# MEDIA_URL 和 MEDIA_ROOT 在启用TOS存储时会被覆盖
# 如果使用TOS存储，MEDIA_ROOT不会被使用，所有文件都保存到TOS
MEDIA_URL = "/media/"
MEDIA_ROOT = BASE_DIR / "media"  # 仅在不使用TOS存储时使用

# Object storage (TOS) configuration
# 如果提供了TOS配置信息（ACCESS_KEY_ID, SECRET_ACCESS_KEY, ENDPOINT_URL, BUCKET），则自动启用TOS存储
# 这样可以确保无论是本地开发环境还是生产环境，只要配置了TOS就会使用TOS存储
TOS_ACCESS_KEY_ID = os.getenv("TOS_ACCESS_KEY_ID")
TOS_SECRET_ACCESS_KEY = os.getenv("TOS_SECRET_ACCESS_KEY")
TOS_REGION_NAME = os.getenv("TOS_REGION_NAME", "cn-beijing")
TOS_ENDPOINT_URL = os.getenv("TOS_ENDPOINT_URL")
TOS_BUCKET = os.getenv("TOS_BUCKET")
TOS_MEDIA_LOCATION = os.getenv("TOS_MEDIA_LOCATION", "uploads")
TOS_CUSTOM_DOMAIN = os.getenv("TOS_CUSTOM_DOMAIN", "")

# 自动启用TOS存储：如果设置了USE_TOS_STORAGE为true，或者提供了完整的TOS配置信息
USE_TOS_STORAGE = (
    os.getenv("DJANGO_USE_TOS_STORAGE", "false").lower() == "true" or
    (bool(TOS_ACCESS_KEY_ID) and bool(TOS_SECRET_ACCESS_KEY) and bool(TOS_ENDPOINT_URL) and bool(TOS_BUCKET))
)

if USE_TOS_STORAGE:
    DEFAULT_FILE_STORAGE = "config.storage.TOSMediaStorage"
    AWS_ACCESS_KEY_ID = TOS_ACCESS_KEY_ID
    AWS_SECRET_ACCESS_KEY = TOS_SECRET_ACCESS_KEY
    AWS_S3_REGION_NAME = TOS_REGION_NAME
    AWS_S3_ENDPOINT_URL = TOS_ENDPOINT_URL
    AWS_S3_SIGNATURE_VERSION = "s3v4"
    AWS_S3_ADDRESSING_STYLE = "virtual"

    _media_prefix = f"{TOS_MEDIA_LOCATION.strip('/')}/" if TOS_MEDIA_LOCATION else ""
    if _media_prefix == "/":
        _media_prefix = ""

    if TOS_CUSTOM_DOMAIN:
        MEDIA_URL = f"https://{TOS_CUSTOM_DOMAIN.rstrip('/')}/{_media_prefix}"
    elif TOS_BUCKET and TOS_ENDPOINT_URL:
        endpoint_host = TOS_ENDPOINT_URL.replace("https://", "").replace("http://", "").rstrip("/")
        MEDIA_URL = f"https://{TOS_BUCKET}.{endpoint_host}/{_media_prefix}"

_cors_origins = os.getenv("DJANGO_CORS_ALLOWED_ORIGINS", "")
CORS_ALLOWED_ORIGINS = [origin.strip() for origin in _cors_origins.split(",") if origin.strip()]

if not CORS_ALLOWED_ORIGINS:
    CORS_ALLOWED_ORIGINS = [
        "http://localhost:3000",
        "http://localhost:5173",
        "http://127.0.0.1:3000",
        "http://127.0.0.1:5173",
    ]

_cors_regex = os.getenv("DJANGO_CORS_ALLOWED_ORIGIN_REGEXES", "")
CORS_ALLOWED_ORIGIN_REGEXES = [regex.strip() for regex in _cors_regex.split(",") if regex.strip()]

if not CORS_ALLOWED_ORIGIN_REGEXES and DEBUG:
    CORS_ALLOWED_ORIGIN_REGEXES = [
        r"^https?://localhost(?::\d+)?$",
        r"^https?://127\.0\.0\.1(?::\d+)?$",
        r"^https?://192\.168\.\d{1,3}\.\d{1,3}(?::\d+)?$",
        r"^https?://10\.\d{1,3}\.\d{1,3}\.\d{1,3}(?::\d+)?$",
        r"^https?://172\.(1[6-9]|2\d|3[0-1])\.\d{1,3}\.\d{1,3}(?::\d+)?$",
    ]

CORS_ALLOW_CREDENTIALS = True

# CORS配置：生产环境不允许允许所有源
_cors_allow_all = os.getenv("DJANGO_CORS_ALLOW_ALL", "")
if _cors_allow_all:
    CORS_ALLOW_ALL_ORIGINS = _cors_allow_all.lower() == "true"
elif DEBUG:
    # 仅在DEBUG模式下允许所有源（开发环境）
    CORS_ALLOW_ALL_ORIGINS = True
else:
    # 生产环境必须明确配置允许的源
    CORS_ALLOW_ALL_ORIGINS = False
    if not CORS_ALLOWED_ORIGINS:
        import sys
        print(
            "警告: 生产环境未配置 CORS_ALLOWED_ORIGINS，可能导致前端无法访问API",
            file=sys.stderr
        )

_csrf_trusted = os.getenv("DJANGO_CSRF_TRUSTED_ORIGINS", "")
CSRF_TRUSTED_ORIGINS = [origin.strip() for origin in _csrf_trusted.split(",") if origin.strip()]

if DEBUG:
    CSRF_TRUSTED_ORIGINS.extend(
        [
            "http://localhost",
            "http://127.0.0.1",
        ]
    )

REST_FRAMEWORK = {
    "DEFAULT_RENDERER_CLASSES": [
        "rest_framework.renderers.JSONRenderer",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "core.authentication.AuthTokenAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
    "EXCEPTION_HANDLER": "config.exception_handler.custom_exception_handler",
    # API限流配置：开发环境完全禁用，生产环境启用防止滥用
    "DEFAULT_THROTTLE_CLASSES": [] if DEBUG else [
        "rest_framework.throttling.AnonRateThrottle",
        "rest_framework.throttling.UserRateThrottle",
        "rest_framework.throttling.ScopedRateThrottle",  # 添加ScopedRateThrottle以支持自定义限流作用域
    ],
    # API限流配置：开发环境禁用，生产环境保持合理限制
    "DEFAULT_THROTTLE_RATES": {} if DEBUG else {
        "anon": "100/hour",  # 匿名用户每小时100次请求
        # 生产环境：10000次/小时（约166次/分钟）
        "user": "10000/hour",
        "uploads_get": "10000/hour",  # 上传列表GET请求
    },
}

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# ==================== 安全配置 ====================

# 文件上传大小限制（防止DoS攻击）
DATA_UPLOAD_MAX_MEMORY_SIZE = 10 * 1024 * 1024  # 10MB
FILE_UPLOAD_MAX_MEMORY_SIZE = 10 * 1024 * 1024  # 10MB
DATA_UPLOAD_MAX_NUMBER_FIELDS = 1000  # 限制表单字段数量

# 安全HTTP头配置
if not DEBUG:
    # 生产环境启用安全头
    SECURE_BROWSER_XSS_FILTER = True
    SECURE_CONTENT_TYPE_NOSNIFF = True
    X_FRAME_OPTIONS = "DENY"
    
    # HSTS (HTTP Strict Transport Security)
    # 注意：仅在HTTPS环境下启用
    SECURE_HSTS_SECONDS = 31536000  # 1年
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_PRELOAD = True
    
    # 如果使用HTTPS，取消下面的注释
    # SECURE_SSL_REDIRECT = True
    # SESSION_COOKIE_SECURE = True
    # CSRF_COOKIE_SECURE = True

# Email configuration
EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
EMAIL_HOST = os.getenv("SMTP_HOST", "smtp.163.com")
EMAIL_PORT = int(os.getenv("SMTP_PORT", "465"))
_use_tls = os.getenv("SMTP_USE_TLS", "false").lower() == "true"
_use_ssl = os.getenv("SMTP_USE_SSL", "true").lower() == "true"

if _use_tls and _use_ssl:
    _use_ssl = False

EMAIL_USE_TLS = _use_tls
EMAIL_USE_SSL = _use_ssl
# 邮箱配置：生产环境必须通过环境变量设置，不允许硬编码密码
EMAIL_HOST_USER = os.getenv("SMTP_USERNAME", "echodraw@163.com")
EMAIL_HOST_PASSWORD = os.getenv("SMTP_PASSWORD")
if not EMAIL_HOST_PASSWORD:
    import sys
    print(
        "警告: SMTP_PASSWORD 环境变量未设置，邮件发送功能可能无法正常工作",
        file=sys.stderr
    )
DEFAULT_FROM_EMAIL = os.getenv("SMTP_FROM_EMAIL", EMAIL_HOST_USER)
EMAIL_TIMEOUT = int(os.getenv("SMTP_TIMEOUT", "15"))

# 缓存配置（使用Redis，与Celery共享Redis实例但使用不同的数据库）
# Celery使用db 0，缓存使用db 1
_redis_cache_url = os.getenv("REDIS_CACHE_URL", "redis://localhost:6379/1")
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': _redis_cache_url,
        'KEY_PREFIX': 'echo_cache',
        'TIMEOUT': 300,  # 默认缓存5分钟
    }
}

# Celery配置
CELERY_ENABLED = os.getenv("CELERY_ENABLED", "false").lower() == "true"
CELERY_BROKER_URL = os.getenv("CELERY_BROKER_URL", "redis://localhost:6379/0")
CELERY_RESULT_BACKEND = os.getenv("CELERY_RESULT_BACKEND", "redis://localhost:6379/0")
CELERY_TIMEZONE = "Asia/Shanghai"
CELERY_ENABLE_UTC = True

# Celery Worker 并发配置（针对图像分析任务优化）
# 推荐配置：根据CPU核心数和内存调整
# - 4核CPU + 8GB内存：concurrency=2
# - 8核CPU + 16GB内存：concurrency=4
# - 16核CPU + 32GB内存：concurrency=8
CELERY_WORKER_CONCURRENCY = int(os.getenv("CELERY_WORKER_CONCURRENCY", "2"))
CELERY_TASK_ACKS_LATE = True  # 任务完成后才确认，避免任务丢失
CELERY_WORKER_PREFETCH_MULTIPLIER = 1  # 每个worker只预取1个任务，避免内存堆积
CELERY_TASK_SOFT_TIME_LIMIT = 300  # 软超时：5分钟（任务可以优雅退出）
CELERY_TASK_TIME_LIMIT = 360  # 硬超时：6分钟（强制终止）
CELERY_TASK_MAX_RETRIES = 2  # 最多重试2次
CELERY_TASK_DEFAULT_RETRY_DELAY = 60  # 重试延迟60秒

# 图像分析配置
# 图片分析时的最大边长（像素），降低此值可以减少计算量和内存使用
# 1536: 平衡性能和质量的推荐值（减少约44%计算量）
# 2048: 高质量但更耗资源
# 800: 优化性能，减少约73%计算量，适合高并发场景
IMAGE_ANALYSIS_MAX_SIDE = int(os.getenv("IMAGE_ANALYSIS_MAX_SIDE", "800"))

# Celery Beat定时任务配置
from celery.schedules import crontab

CELERY_BEAT_SCHEDULE = {
    "generate-monthly-reports": {
        "task": "core.tasks.generate_monthly_reports_task",
        "schedule": crontab(hour=2, minute=0, day_of_month=1),  # 每月1号凌晨2点执行
        "options": {"expires": 3600},  # 任务过期时间1小时
    },
}